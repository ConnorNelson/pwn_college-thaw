Overview
[[[
Level 4 - LFSR 1

Difficulty:
  Rules: [***] (777 win streak, 2000 rounds)
  Seed:  [*--] (fixed)
  PRNG:  [*--] (7-bit LFSR)
]]]

Description
[[[
Now comes the fun part - predicting future outputs on previous outputs alone!
The PRNG implemented here is a Linear Feedback Shift Register - one of the
simplest, yet effective and elegant solutions for RNG. Check the following
hint and play around with the lfsr_toy in /challenge/ to get the hang of it!
]]]

LFSR basics
[[[
Linear - it can be reversed!
Feedback - it feeds it's own values back to itself!
Shift - take all the bits and move them right one place!
Register - that's where the bits are stored!

Let's take 10110 as the initial state, with "taps" at 2 and 3.
First, we figure out the feedback part. We need to get a new bit, and the
taps are going to be the source.

 1 0 1 1 0
     ^ ^
Those two get XOR'd together to get the new bit.
XOR (^) = eXclusive OR = 0 if numbers are same and 1 if they're different
1 ^ 1 = 0 - that's our new bit!

Now for the shift! It effectively divides the number represented by the bits
by two, and can be done with "number >> 1" or "number / 2" in C.

 1 0 1 1 0 >>
  v   v   v
 . 1 0 1 1 >> 0
 ^new^state   ^output!

The output is used "as-is" to decide the coin flip in the challenge, and full
numbers can be generated by reading multiple bits in a loop.
Now we get the new bit we calculated earlier and place it on the left:

 . 1 0 1 1
 v
 0 1 0 1 1

And now we start over!

01011 >> 10101 >> 1
  vv     ^
  0^1=1>>^

10101 >> 11010 >> 1
  vv     ^
  1^0=1>>^

11010 >> 11101 >> 0
  vv     ^
  0^1=1>>^

1. Calculate the new bit by XORing the values at the taps.
2. Read the least significant bit to get the output.
3. Shift all bits to the right.
4. New bit is the new most signigicant bit.
5. Repeat!

This is how the LFSR is implemented in the challenges 4 and 5, but it can take
many forms and be combined with other algorithms to make it stronger!

LFSRs are very popular, so any querry in a search engine or video hosting site
of your choice will come up with many more results and explanations.

also play with LFSR Toy in /challenge/ its Very Cool if i do say so myself;)
]]]

Intended approach
[[[
While this challenge's implementation of LFSR can be beaten in several ways,
it is mostly intended as a practical guide on infering the RNG's internal
state from its outputs alone. Reverse-engineer the algorithm, get a few
results from the challenge and use them to match the challenge's outputs!
]]]

Hint 1
[[[
In case of LFSRs, you can get the initial state by just reading the ammount
of bits equal to LFSR's length. Combine that and the fact that the seed is
fixed to develop a flexible solution that can be reused in the future.
]]]

Bonus hint
[[[
LFSR's outputs loop around after 2 to the power of LFSR's length minus one.
Here it's 2**7-1=127, so exploiting that is a valid approach!
The next challenge though...
]]]
